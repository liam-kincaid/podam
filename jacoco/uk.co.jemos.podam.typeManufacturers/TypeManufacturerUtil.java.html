<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TypeManufacturerUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">podam</a> &gt; <a href="index.source.html" class="el_package">uk.co.jemos.podam.typeManufacturers</a> &gt; <span class="el_source">TypeManufacturerUtil.java</span></div><h1>TypeManufacturerUtil.java</h1><pre class="source lang-java linenums">package uk.co.jemos.podam.typeManufacturers;

import org.apache.commons.lang3.ArrayUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import uk.co.jemos.podam.api.DataProviderStrategy;
import uk.co.jemos.podam.api.ObjectStrategy;
import uk.co.jemos.podam.api.PodamUtils;
import uk.co.jemos.podam.common.*;

import jakarta.validation.Constraint;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

import java.lang.annotation.Annotation;
import java.lang.reflect.*;
import java.util.*;
import java.util.concurrent.atomic.AtomicReference;

/**
 * Type Manufacturer utility class.
 *
 * Created by tedonema on 01/07/2015.
 *
 * @since 6.0.0.RELEASE
 */
<span class="nc" id="L30">public abstract class TypeManufacturerUtil {</span>
    
    /** The application logger */
<span class="fc" id="L33">    private static final Logger LOG = LoggerFactory.getLogger(TypeManufacturerUtil.class);</span>

    /**
     * It returns a {@link AttributeStrategy} if one was specified in
     * annotations, or {@code null} otherwise.
     *
     * @param strategy
     *            The data provider strategy
     * @param annotations
     *            The list of annotations, irrelevant annotations will be removed
     * @param attributeType
     *            Type of attribute expected to be returned
     * @return {@link AttributeStrategy}, if {@link PodamStrategyValue} or bean
     *         validation constraint annotation was found among annotations
     * @throws IllegalAccessException
     *         if attribute strategy cannot be instantiated
     * @throws InstantiationException
     *         if attribute strategy cannot be instantiated
     * @throws SecurityException 
     *         if access security is violated
     * @throws InvocationTargetException
     *         if invocation failed
     * @throws IllegalArgumentException 
     *         if illegal argument provided to a constructor
     */
    public static AttributeStrategy&lt;?&gt; findAttributeStrategy(DataProviderStrategy strategy,
            List&lt;Annotation&gt; annotations, Class&lt;?&gt; attributeType)
            throws InstantiationException, IllegalAccessException, SecurityException, IllegalArgumentException, InvocationTargetException {

<span class="fc" id="L62">        List&lt;Annotation&gt; localAnnotations = new ArrayList&lt;Annotation&gt;(annotations);</span>
<span class="fc" id="L63">        List&lt;Class&lt;? extends Annotation&gt;&gt; annotationsToCheck = new ArrayList&lt;Class&lt;? extends Annotation&gt;&gt;();</span>
<span class="fc" id="L64">        List&lt;Class&lt;? extends Annotation&gt;&gt; constraintAnnotationsWithoutRegisteredStrategy = new ArrayList&lt;Class&lt;? extends Annotation&gt;&gt;();</span>
<span class="fc" id="L65">        Iterator&lt;Annotation&gt; localAnnotationsIter = localAnnotations.iterator();</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">        while (localAnnotationsIter.hasNext()) {</span>
<span class="fc" id="L67">            Annotation annotation = localAnnotationsIter.next();</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">            if (annotation instanceof PodamStrategyValue) {</span>
<span class="fc" id="L69">                PodamStrategyValue strategyAnnotation = (PodamStrategyValue) annotation;</span>
<span class="fc" id="L70">                return strategyAnnotation.value().newInstance();</span>
            }

            /* Podam annotation is present, this will be handled later by type manufacturers */
<span class="fc bfc" id="L74" title="All 2 branches covered.">            if (annotation.annotationType().getAnnotation(PodamAnnotation.class) != null) {</span>
<span class="fc" id="L75">                return null;</span>
            }

			/* Find real class out of proxy */
<span class="fc" id="L79">            Class&lt;? extends Annotation&gt; annotationClass = annotation.getClass();</span>
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">            if (Proxy.isProxyClass(annotationClass)) {</span>
<span class="fc" id="L81">                Class&lt;?&gt;[] interfaces = annotationClass.getInterfaces();</span>
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">                if (interfaces.length == 1) {</span>
                    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L84">                    Class&lt;? extends Annotation&gt; tmp = (Class&lt;? extends Annotation&gt;) interfaces[0];</span>
<span class="fc" id="L85">                    annotationClass = tmp;</span>
                }
            }

<span class="fc" id="L89">            AttributeStrategy&lt;?&gt; attrStrategy = strategy.getStrategyForAnnotation(annotationClass);</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">            if (null != attrStrategy) {</span>
<span class="fc" id="L91">                return attrStrategy;</span>
            } else {
<span class="fc bfc" id="L93" title="All 2 branches covered.">                for (Class&lt;?&gt; iface : annotationClass.getInterfaces()) {</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">                    if (Annotation.class.isAssignableFrom(iface)) {</span>
                        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L96">                        Class&lt;? extends Annotation&gt; tmp = (Class&lt;? extends Annotation&gt;) iface;</span>
<span class="fc" id="L97">                        annotationsToCheck.add(tmp);</span>
                    }
                }
            }

<span class="fc bfc" id="L102" title="All 2 branches covered.">            if (annotation.annotationType().getAnnotation(Constraint.class) != null) {</span>
<span class="pc bpc" id="L103" title="2 of 6 branches missed.">                if (annotation instanceof NotNull ||</span>
                        annotation instanceof NotBlank ||
                        annotation instanceof NotEmpty ||
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">                        annotation.annotationType().getName().equals(&quot;org.hibernate.validator.constraints.NotEmpty&quot;) ||</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">                        annotation.annotationType().getName().equals(&quot;org.hibernate.validator.constraints.NotBlank&quot;)) {</span>
					/* We don't need to do anything for NotNull constraint */
<span class="fc" id="L109">                    localAnnotationsIter.remove();</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">                } else if (!NotNull.class.getPackage().equals(annotationClass.getPackage())) {</span>
<span class="nc" id="L111">                    constraintAnnotationsWithoutRegisteredStrategy.add(annotationClass);</span>
                }
            } else {
<span class="fc" id="L114">                localAnnotationsIter.remove();</span>
            }
<span class="fc" id="L116">        }</span>

<span class="fc" id="L118">        Iterator&lt;Class&lt;? extends Annotation&gt;&gt; annotationsToCheckIter = annotationsToCheck.iterator();</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">        while (annotationsToCheckIter.hasNext()) {</span>
<span class="fc" id="L120">            Class&lt;? extends Annotation&gt; annotationClass = annotationsToCheckIter.next();</span>
<span class="fc" id="L121">            AttributeStrategy&lt;?&gt; attrStrategy = strategy.getStrategyForAnnotation(annotationClass);</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">            if (null != attrStrategy) {</span>
<span class="fc" id="L123">                return attrStrategy;</span>
            } else {
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">                for (Class&lt;?&gt; iface : annotationClass.getInterfaces()) {</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">                    if (Annotation.class.isAssignableFrom(iface)) {</span>
                        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L128">                        Class&lt;? extends Annotation&gt; tmp = (Class&lt;? extends Annotation&gt;) iface;</span>
<span class="nc" id="L129">                        annotationsToCheck.add(tmp);</span>
                    }
                }
            }
<span class="fc" id="L133">        }</span>

<span class="pc bpc" id="L135" title="1 of 2 branches missed.">        for (Class&lt;? extends Annotation&gt; constraintAnnotationWithoutRegisteredStrategy : constraintAnnotationsWithoutRegisteredStrategy) {</span>
            /* This message is logged only when no applicable strategy is found for given annotation - neither for
             * the annotation itself nor for any interface it implements. */
<span class="nc" id="L138">            LOG.warn(&quot;Please, register AttributeStrategy for custom &quot;</span>
                + &quot;constraint {}, in DataProviderStrategy! Value &quot;
                + &quot;will be left to null&quot;, constraintAnnotationWithoutRegisteredStrategy);
<span class="nc" id="L141">        }</span>

<span class="fc" id="L143">        AttributeStrategy&lt;?&gt; retValue = null;</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">        if (!localAnnotations.isEmpty()</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">                &amp;&amp; !Collection.class.isAssignableFrom(attributeType)</span>
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">                &amp;&amp; !Map.class.isAssignableFrom(attributeType)</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">                &amp;&amp; !attributeType.isArray()) {</span>

<span class="fc" id="L149">            retValue = new BeanValidationStrategy(attributeType);</span>
        }

<span class="fc" id="L152">        return retValue;</span>
    }

    /**
     * Finds suitable static constructors for POJO instantiation
     * &lt;p&gt;
     * This method places required and provided types for object creation into a
     * map, which will be used for type mapping.
     * &lt;/p&gt;
     *
     * @param factoryClass
     *            Factory class to produce the POJO
     * @param pojoClass
     *            Typed class
     * @return an array of suitable static constructors found
     */
    public static Method[] findSuitableConstructors(final Class&lt;?&gt; factoryClass,
            final Class&lt;?&gt; pojoClass) {

        // If no publicly accessible constructors are available,
        // the best we can do is to find a constructor (e.g.
        // getInstance())

<span class="fc" id="L175">        Method[] declaredMethods = factoryClass.getDeclaredMethods();</span>
<span class="fc" id="L176">        List&lt;Method&gt; constructors = new ArrayList&lt;Method&gt;();</span>

        // A candidate factory method is a method which returns the
        // Class type
<span class="fc bfc" id="L180" title="All 2 branches covered.">        for (Method candidateConstructor : declaredMethods) {</span>

<span class="fc bfc" id="L182" title="All 2 branches covered.">            if (candidateConstructor.getReturnType().equals(pojoClass)) {</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">                if (Modifier.isStatic(candidateConstructor.getModifiers())</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">                        || !factoryClass.equals(pojoClass)) {</span>
<span class="fc" id="L185">                    constructors.add(candidateConstructor);</span>
                }
            }
        }

<span class="fc" id="L190">        return constructors.toArray(new Method[constructors.size()]);</span>
    }

    /**
     * Searches for annotation with information about collection/map size
     * and filling strategies
     *
     * @param strategy
     *        a data provider strategy
     * @param annotations
     *        a list of annotations to inspect
     * @param collectionElementType
     *        a collection element type
     * @param elementStrategyHolder
     *        a holder to pass found element strategy back to the caller,
     *        can be null
     * @param keyStrategyHolder
     *        a holder to pass found key strategy back to the caller,
     *        can be null
     * @return
     *        A number of element in collection or null, if no annotation was
     *        found
     * @throws InstantiationException
     *        A strategy cannot be instantiated
     * @throws IllegalAccessException
     *        A strategy cannot be instantiated
     */
    public static Integer findCollectionSize( DataProviderStrategy strategy,
                                        List&lt;Annotation&gt; annotations,
                                        Class&lt;?&gt; collectionElementType,
                                        Holder&lt;AttributeStrategy&lt;?&gt;&gt; elementStrategyHolder,
                                        Holder&lt;AttributeStrategy&lt;?&gt;&gt; keyStrategyHolder)
            throws InstantiationException, IllegalAccessException {

        // If the user defined a strategy to fill the collection elements,
        // we use it
<span class="fc" id="L226">        Size size = null;</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">        for (Annotation annotation : annotations) {</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">            if (annotation instanceof PodamCollection) {</span>

<span class="fc" id="L230">                PodamCollection collectionAnnotation = (PodamCollection) annotation;</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">                if (null != elementStrategyHolder) {</span>

<span class="fc" id="L233">                    Class&lt;? extends AttributeStrategy&lt;?&gt;&gt; attributeStrategy</span>
<span class="fc" id="L234">                            = collectionAnnotation.collectionElementStrategy();</span>
<span class="pc bpc" id="L235" title="1 of 4 branches missed.">                    if (null == attributeStrategy || ObjectStrategy.class.isAssignableFrom(attributeStrategy)) {</span>
<span class="fc" id="L236">                        attributeStrategy = collectionAnnotation.mapElementStrategy();</span>
                    }
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">                    if (null != attributeStrategy) {</span>
<span class="fc" id="L239">                        elementStrategyHolder.setValue(attributeStrategy.newInstance());</span>
                    }
                }
<span class="fc bfc" id="L242" title="All 2 branches covered.">                if (null != keyStrategyHolder) {</span>

<span class="fc" id="L244">                    Class&lt;? extends AttributeStrategy&lt;?&gt;&gt; attributeStrategy</span>
<span class="fc" id="L245">                            = collectionAnnotation.mapKeyStrategy();</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">                    if (null != attributeStrategy) {</span>
<span class="fc" id="L247">                        keyStrategyHolder.setValue(attributeStrategy.newInstance());</span>
                    }
                }
<span class="fc" id="L250">                return collectionAnnotation.nbrElements();</span>

<span class="pc bpc" id="L252" title="1 of 2 branches missed.">            } else if (annotation instanceof Size) {</span>

<span class="fc" id="L254">                size = (Size) annotation;</span>
            }
<span class="fc" id="L256">        }</span>

<span class="fc" id="L258">        Integer nbrElements = strategy</span>
<span class="fc" id="L259">                .getNumberOfCollectionElements(collectionElementType);</span>

<span class="fc bfc" id="L261" title="All 2 branches covered.">        if (null != size) {</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">            if (nbrElements &gt; size.max()) {</span>
<span class="fc" id="L263">                nbrElements = size.max();</span>
            }
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">            if (nbrElements &lt; size.min()) {</span>
<span class="nc" id="L266">                nbrElements = size.min();</span>
            }
        }

<span class="fc" id="L270">        return nbrElements;</span>
    }

    /**
     * Utility to merge actual types with supplied array of generic type
     * substitutions
     *
     * @param attributeType
     *            actual type of object
     * @param genericAttributeType
     *            generic type of object
     * @param suppliedTypes
     *            an array of supplied types for generic type substitution
     * @param manufacturingCtx
     *            a context with a map relating the generic class arguments (&quot;&amp;lt;T, V&amp;gt;&quot; for
     *            example) with their actual types
     * @return An array of merged actual and supplied types with generic types
     *            resolved
     */
    public static Type[] mergeActualAndSuppliedGenericTypes(
            Class&lt;?&gt; attributeType, Type genericAttributeType, Type[] suppliedTypes,
            ManufacturingContext manufacturingCtx) {

<span class="fc" id="L293">        TypeVariable&lt;?&gt;[] actualTypes = attributeType.getTypeParameters();</span>

<span class="fc bfc" id="L295" title="All 2 branches covered.">        if (actualTypes.length &lt;= suppliedTypes.length) {</span>
<span class="fc" id="L296">            return suppliedTypes;</span>
        }

<span class="fc" id="L299">        Type[] genericTypes = null;</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">        if (genericAttributeType instanceof ParameterizedType) {</span>
<span class="fc" id="L301">            ParameterizedType paramType = (ParameterizedType) genericAttributeType;</span>
<span class="fc" id="L302">            genericTypes = paramType.getActualTypeArguments();</span>
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">        } else if (genericAttributeType instanceof WildcardType) {</span>
<span class="nc" id="L304">            WildcardType wildcardType = (WildcardType) genericAttributeType;</span>
<span class="nc" id="L305">            genericTypes = wildcardType.getLowerBounds();</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">            if (ArrayUtils.isEmpty(genericTypes)) {</span>
<span class="nc" id="L307">                genericTypes = wildcardType.getUpperBounds();</span>
            }
        }

<span class="fc" id="L311">        List&lt;Type&gt; resolvedTypes = new ArrayList&lt;Type&gt;();</span>
<span class="fc" id="L312">        List&lt;Type&gt; substitutionTypes = new ArrayList&lt;Type&gt;(Arrays.asList(suppliedTypes));</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">        for (int i = 0; i &lt; actualTypes.length; i++) {</span>

<span class="fc" id="L315">            Type type = null;</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">            if (actualTypes[i] instanceof TypeVariable) {</span>
<span class="fc" id="L317">                type = manufacturingCtx.resolveType(((TypeVariable&lt;?&gt;)actualTypes[i]).getName());</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">            } else if (actualTypes[i] instanceof WildcardType) {</span>
<span class="nc" id="L319">                AtomicReference&lt;Type[]&gt; methodGenericTypeArgs</span>
                        = new AtomicReference&lt;Type[]&gt;(PodamConstants.NO_TYPES);
<span class="nc" id="L321">                type = TypeManufacturerUtil.resolveGenericParameter(actualTypes[i], manufacturingCtx,</span>
                        methodGenericTypeArgs);
            }

<span class="pc bpc" id="L325" title="1 of 4 branches missed.">            if ((type == null) &amp;&amp; (genericTypes != null)) {</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">                if (genericTypes[i] instanceof Class) {</span>
<span class="nc" id="L327">                    type = genericTypes[i];</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">                } else if (genericTypes[i] instanceof WildcardType) {</span>
<span class="nc" id="L329">                    AtomicReference&lt;Type[]&gt; methodGenericTypeArgs</span>
                            = new AtomicReference&lt;Type[]&gt;(PodamConstants.NO_TYPES);
<span class="nc" id="L331">                    type = resolveGenericParameter(genericTypes[i], manufacturingCtx,</span>
                            methodGenericTypeArgs);
<span class="nc bnc" id="L333" title="All 2 branches missed.">                } else if (genericTypes[i] instanceof ParameterizedType) {</span>
<span class="nc" id="L334">                    type = genericTypes[i];</span>
                } else {
<span class="nc" id="L336">                    LOG.debug(&quot;Skipping type {} {}&quot;, actualTypes[i], genericTypes[i]);</span>
                }
            }

<span class="fc bfc" id="L340" title="All 2 branches covered.">            if (type != null) {</span>
<span class="fc" id="L341">                resolvedTypes.add(type);</span>
<span class="pc bpc" id="L342" title="3 of 4 branches missed.">                if (!substitutionTypes.isEmpty() &amp;&amp; substitutionTypes.get(0).equals(type)) {</span>
<span class="nc" id="L343">                    substitutionTypes.remove(0);</span>
                }
            }
        }
<span class="fc" id="L347">        Type[] resolved = resolvedTypes.toArray(new Type[resolvedTypes.size()]);</span>
<span class="fc" id="L348">        Type[] supplied = substitutionTypes.toArray(new Type[substitutionTypes.size()]);</span>
<span class="fc" id="L349">        return ArrayUtils.addAll(resolved, supplied);</span>
    }

    /**
     * It resolves generic parameter type
     *
     *
     * @param paramType
     *            The generic parameter type
     * @param manufacturingCtx
     *            A manufacturing context with a map of resolved types
     * @param methodGenericTypeArgs
     *            Return value posible generic types of the generic parameter
     *            type
     * @return value for class representing the generic parameter type
     */
    public static Class&lt;?&gt; resolveGenericParameter(Type paramType,
                                             ManufacturingContext manufacturingCtx,
                                             AtomicReference&lt;Type[]&gt; methodGenericTypeArgs) {

<span class="fc" id="L369">        Class&lt;?&gt; parameterType = null;</span>

        //Safe copy
<span class="fc" id="L372">        manufacturingCtx.cloneTypeArgsMap();</span>

<span class="fc" id="L374">        methodGenericTypeArgs.set(PodamConstants.NO_TYPES);</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">        if (paramType instanceof Class) {</span>
<span class="fc" id="L376">            parameterType = (Class&lt;?&gt;) paramType;</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">        } else if (paramType instanceof TypeVariable&lt;?&gt;) {</span>
<span class="fc" id="L378">            final TypeVariable&lt;?&gt; typeVariable = (TypeVariable&lt;?&gt;) paramType;</span>
<span class="fc" id="L379">            final Type type = manufacturingCtx.resolveType(typeVariable.getName());</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">            if (type != null) {</span>
<span class="fc" id="L381">                parameterType = resolveGenericParameter(type, manufacturingCtx,</span>
                        methodGenericTypeArgs);
            }
<span class="fc bfc" id="L384" title="All 2 branches covered.">        } else if (paramType instanceof ParameterizedType) {</span>
<span class="fc" id="L385">            ParameterizedType pType = (ParameterizedType) paramType;</span>
<span class="fc" id="L386">            parameterType = (Class&lt;?&gt;) pType.getRawType();</span>
<span class="fc" id="L387">            Type[] actualTypeArgs = pType.getActualTypeArguments();</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">            if (!manufacturingCtx.isTypeArgsEmpty()) {</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">                for (int i = 0; i &lt; actualTypeArgs.length; i++) {</span>
<span class="fc" id="L390">                    Class&lt;?&gt; tmp = resolveGenericParameter(actualTypeArgs[i],</span>
                        manufacturingCtx, methodGenericTypeArgs);
<span class="fc bfc" id="L392" title="All 2 branches covered.">                    if (tmp != actualTypeArgs[i]) {</span>
                        /* If actual type argument has its own arguments,
                         * we will loose them now, so we will leave type unresolved
                         * until lower levels of type resolution */
<span class="fc bfc" id="L396" title="All 2 branches covered.">                        if (ArrayUtils.isEmpty(methodGenericTypeArgs.get())) {</span>
<span class="fc" id="L397">                            actualTypeArgs[i] = tmp;</span>
                        }
                    }
                }
            }
<span class="fc" id="L402">            methodGenericTypeArgs.set(actualTypeArgs);</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">        } else if (paramType instanceof WildcardType) {</span>
<span class="fc" id="L404">            WildcardType wType = (WildcardType) paramType;</span>
<span class="fc" id="L405">            Type[] bounds = wType.getLowerBounds();</span>
            String msg;
<span class="fc bfc" id="L407" title="All 2 branches covered.">            if (ArrayUtils.isNotEmpty(bounds)) {</span>
<span class="fc" id="L408">                msg = &quot;Lower bounds:&quot;;</span>
            } else {
<span class="fc" id="L410">                bounds = wType.getUpperBounds();</span>
<span class="fc" id="L411">                msg = &quot;Upper bounds:&quot;;</span>
            }
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">            if (ArrayUtils.isNotEmpty(bounds)) {</span>
<span class="fc" id="L414">                LOG.debug(msg + Arrays.toString(bounds));</span>
<span class="fc" id="L415">                parameterType = resolveGenericParameter(bounds[0], manufacturingCtx,</span>
                        methodGenericTypeArgs);
            }
        }

<span class="fc bfc" id="L420" title="All 2 branches covered.">        if (parameterType == null) {</span>
<span class="fc" id="L421">            LOG.warn(&quot;Unrecognized type {}. Will use Object instead&quot;,</span>
                    paramType);
<span class="fc" id="L423">            parameterType = Object.class;</span>
        }
<span class="fc" id="L425">        manufacturingCtx.restoreTypeArgsMap();</span>
<span class="fc" id="L426">        return parameterType;</span>
    }


    /**
     * It retrieves the value for the {@link PodamStrategyValue} annotation with
     * which the attribute was annotated
     *
     * @param attributeType
     *            The attribute type, used for type checking
     * @param annotations
     *            Annotations attached to the attribute
     * @param attributeStrategy
     *            The {@link AttributeStrategy} to use
     * @return The value for the {@link PodamStrategyValue} annotation with
     *         which the attribute was annotated
     * @throws IllegalArgumentException
     *             If the type of the data strategy defined for the
     *             {@link PodamStrategyValue} annotation is not assignable to
     *             the annotated attribute. This de facto guarantees type
     *             safety.
     */
    public static Object returnAttributeDataStrategyValue(Class&lt;?&gt; attributeType,
            List&lt;Annotation&gt; annotations,
            AttributeStrategy&lt;?&gt; attributeStrategy)
            throws IllegalArgumentException {

<span class="fc bfc" id="L453" title="All 2 branches covered.">        if (null == attributeStrategy) {</span>
<span class="fc" id="L454">            return null;</span>
        }

<span class="fc" id="L457">        Object retValue = attributeStrategy.getValue(attributeType, annotations);</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">        if (retValue != null) {</span>

<span class="fc bfc" id="L460" title="All 2 branches covered.">            Class&lt;?&gt; desiredType = attributeType.isPrimitive() ?</span>
<span class="fc" id="L461">                    PodamUtils.primitiveToBoxedType(attributeType) : attributeType;</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">            if (!desiredType.isAssignableFrom(retValue.getClass())) {</span>
<span class="fc" id="L463">                String errMsg = &quot;The AttributeStrategy &quot;</span>
<span class="fc" id="L464">                        + attributeStrategy.getClass().getName()</span>
                        + &quot; produced value of type &quot;
<span class="fc" id="L466">                        + retValue.getClass().getName()</span>
                        + &quot; incompatible with attribute type &quot;
<span class="fc" id="L468">                        + attributeType.getName();</span>
<span class="fc" id="L469">                throw new IllegalArgumentException(errMsg);</span>
            } else {
<span class="fc" id="L471">                LOG.debug(&quot;The parameter {} will be filled using the following strategy {}&quot;,</span>
                        attributeType, attributeStrategy);
            }
        }

<span class="fc" id="L476">        return retValue;</span>

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>