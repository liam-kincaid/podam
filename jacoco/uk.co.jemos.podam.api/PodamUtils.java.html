<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PodamUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">podam</a> &gt; <a href="index.source.html" class="el_package">uk.co.jemos.podam.api</a> &gt; <span class="el_source">PodamUtils.java</span></div><h1>PodamUtils.java</h1><pre class="source lang-java linenums">/**
 *
 */
package uk.co.jemos.podam.api;

import uk.co.jemos.podam.common.PodamConstants;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.concurrent.ThreadLocalRandom;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.Set;

/**
 * PODAM Utilities class.
 *
 * @author mtedone
 *
 * @since 1.0.0
 *
 */
<span class="nc" id="L28">public abstract class PodamUtils {</span>

	// ----------------------&gt;&gt; Constants

	/** An array of valid String characters */
<span class="fc" id="L33">	public static final char[] NICE_ASCII_CHARACTERS = new char[] { 'a', 'b',</span>
			'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
			'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B',
			'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
			'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1',
			'2', '3', '4', '5', '6', '7', '8', '9', '_' };

	/** The application logger. */
<span class="fc" id="L41">	private static final Logger LOG = LoggerFactory.getLogger(PodamUtils.class);</span>

	/**
	 * It returns a {@link Field} matching the attribute name or null if a field
	 * was not found.
	 *
	 * @param pojoClass
	 *            The class supposed to contain the field
	 * @param attributeName
	 *            The field name
	 *
	 * @return a {@link Field} matching the attribute name or null if a field
	 *         was not found.
	 */
	public static Field getField(Class&lt;?&gt; pojoClass, String attributeName) {

<span class="fc" id="L57">		Class&lt;?&gt; clazz = pojoClass;</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">		while (clazz != null) {</span>
			try {
<span class="fc" id="L60">				return clazz.getDeclaredField(attributeName);</span>
<span class="fc" id="L61">			} catch (NoSuchFieldException e) {</span>
<span class="fc" id="L62">				clazz = clazz.getSuperclass();</span>
<span class="fc" id="L63">			}</span>
		}

<span class="fc" id="L66">		LOG.warn(&quot;A field could not be found for attribute '{}[{}]'&quot;,</span>
				pojoClass, attributeName);
<span class="fc" id="L68">		return null;</span>
	}

	/**
	 * It returns an value for a {@link Field} matching the attribute
	 * name or null if a field was not found.
	 *
	 * @param &lt;T&gt;
	 *            The type of field to be returned
	 * @param pojo
	 *            The class supposed to contain the field
	 * @param attributeName
	 *            The field name
	 *
	 * @return an instance of {@link Field} matching the attribute name or
	 *         null if a field was not found.
	 */
	public static &lt;T&gt; T getFieldValue(Object pojo, String attributeName) {
<span class="fc" id="L86">		T retValue = null;</span>

		try {
<span class="fc" id="L89">			Field field = PodamUtils.getField(pojo.getClass(), attributeName);</span>

<span class="fc bfc" id="L91" title="All 2 branches covered.">			if (field != null) {</span>

				// It allows to invoke Field.get on private fields
<span class="fc" id="L94">				field.setAccessible(true);</span>

				@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L97">				T t = (T) field.get(pojo);</span>
<span class="fc" id="L98">				retValue = t;</span>
<span class="fc" id="L99">			} else {</span>

<span class="fc" id="L101">				LOG.info(&quot;The field {}[{}] didn't exist.&quot;, pojo.getClass(), attributeName);</span>
			}

<span class="nc" id="L104">		} catch (Exception e) {</span>

<span class="nc" id="L106">			LOG.warn(&quot;We couldn't get default value for {}[{}]&quot;,</span>
<span class="nc" id="L107">					pojo.getClass(), attributeName, e);</span>
<span class="fc" id="L108">		}</span>

<span class="fc" id="L110">		return retValue;</span>
	}

	/**
	 * It returns an value from getter for a {@link Field} matching the attribute
	 * name or null if a field was not found.
	 *
	 * @param &lt;T&gt;
	 *            The type of field to be returned
	 * @param pojo
	 *            The class supposed to contain the field
	 * @param attributeName
	 *            The field name
	 *
	 * @return an instance of {@link Field} matching the attribute name or
	 *         null if a field was not found.
	 */
	public static &lt;T&gt; T getFieldValueWithGetter(Object pojo, String attributeName) {
<span class="fc" id="L128">		T retValue = null;</span>

		try {
<span class="pc" id="L131">			Method method = pojo.getClass().getMethod(&quot;get&quot; +</span>
<span class="fc" id="L132">					+ Character.toUpperCase(attributeName.charAt(0))</span>
<span class="fc" id="L133">					+ attributeName.substring(1), PodamConstants.NO_CLASSES);</span>

<span class="nc bnc" id="L135" title="All 2 branches missed.">			if (method != null) {</span>

				// It allows to invoke Field.get on private fields
<span class="nc" id="L138">				method.setAccessible(true);</span>

				@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L141">				T t = (T) method.invoke(pojo, PodamConstants.NO_ARGS);</span>
<span class="nc" id="L142">				retValue = t;</span>
<span class="nc" id="L143">			} else {</span>

<span class="nc" id="L145">				LOG.info(&quot;The field {}[{}] didn't exist.&quot;, pojo.getClass(), attributeName);</span>
			}

<span class="fc" id="L148">		} catch (Exception e) {</span>

<span class="fc" id="L150">			LOG.warn(&quot;We couldn't get default value for {}[{}]&quot;,</span>
<span class="fc" id="L151">					pojo.getClass(), attributeName, e);</span>
<span class="nc" id="L152">		}</span>

<span class="fc" id="L154">		return retValue;</span>
	}

	/**
	 * Searches among set of a class'es methods and selects the one defined in
	 * the most specific descend of the hierarchy tree
	 *
	 * @param methods a set of methods to choose from
	 * @return the selected method
	 */
	public static Method selectLatestMethod(Set&lt;Method&gt; methods) {
		/* We want to find a method defined the latest */
<span class="fc" id="L166">		Method selected = null;</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">		for (Method method : methods) {</span>
<span class="pc bpc" id="L168" title="1 of 4 branches missed.">			if (selected == null || selected.getDeclaringClass().isAssignableFrom(method.getDeclaringClass())) {</span>
<span class="fc" id="L169">				selected = method;</span>
			}
<span class="fc" id="L171">		}</span>
<span class="fc" id="L172">		return selected;</span>
	}

	/**
	 * Given the attribute and setter it combines annotations from them
	 * or an empty collection if no custom annotations were found
	 *
	 * @param attribute
	 *            The class attribute
	 * @param methods
	 *            List of setters and getter to check annotations
	 * @return all annotations for the attribute
	 */
	public static List&lt;Annotation&gt; getAttributeAnnotations(final Field attribute,
			final Method... methods) {

<span class="fc" id="L188">		List&lt;Annotation&gt; retValue = new ArrayList&lt;Annotation&gt;();</span>

<span class="fc bfc" id="L190" title="All 2 branches covered.">		if (null != attribute) {</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">			for (Annotation annotation : attribute.getAnnotations()) {</span>
<span class="fc" id="L192">				retValue.add(annotation);</span>
			}
		}
<span class="fc bfc" id="L195" title="All 2 branches covered.">		for (Method method : methods) {</span>
<span class="fc" id="L196">			Annotation[][] paramAnnotations = method.getParameterAnnotations();</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">			if (paramAnnotations.length &gt; 0) {</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">				for (Annotation annotation : paramAnnotations[0]) {</span>
<span class="fc" id="L199">					retValue.add(annotation);</span>
				}
			} else {
<span class="fc bfc" id="L202" title="All 2 branches covered.">				for (Annotation annotation : method.getAnnotations()) {</span>
<span class="fc" id="L203">					retValue.add(annotation);</span>
				}
			}
		}

<span class="fc" id="L208">		return retValue;</span>
	}

	/**
	 * Generates random character from set valid for identifiers in Java language
	 *
	 * @return random character suitable for identifier
	 */
	public static Character getNiceCharacter() {

<span class="fc" id="L218">		int randomCharIdx = getIntegerInRange(0, NICE_ASCII_CHARACTERS.length - 1);</span>
<span class="fc" id="L219">		return NICE_ASCII_CHARACTERS[randomCharIdx];</span>
	}

	/**
	 * Generates random string from set valid for identifiers in Java language
	 *
	 * @param length
	 *            The length of the strings to generate
	 * @return random string suitable for identifier
	 */
	public static String getNiceString(int length) {

<span class="fc" id="L231">        StringBuilder sb = new StringBuilder(length);</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">		while (sb.length() &lt; length) {</span>
<span class="fc" id="L233">            sb.append(PodamUtils.getNiceCharacter());</span>
        }
<span class="fc" id="L235">		return sb.toString();</span>
	}

	/**
	 * It returns a long/Long value between min and max value (included).
	 * 
	 * @param minValue
	 *            The minimum value for the returned value
	 * @param maxValue
	 *            The maximum value for the returned value
	 * @return A long/Long value between min and max value (included).
	 */
	public static long getLongInRange(long minValue, long maxValue) {
<span class="fc" id="L248">		return (long) (getDoubleInRange(minValue - 0.5, maxValue + 0.5 - (1 / Long.MAX_VALUE)) + 0.5);</span>
	}

	/**
	 * It returns a random int/Integer value between min and max value (included).
	 * 
	 * @param minValue
	 *            The minimum value for the returned value
	 * @param maxValue
	 *            The maximum value for the returned value
	 * @return An int/Integer value between min and max value (included).
	 */
	public static int getIntegerInRange(int minValue, int maxValue) {
<span class="fc" id="L261">		return (int) getLongInRange(minValue, maxValue);</span>
	}

	/**
	 * It returns a double/Double value between min and max value (included).
	 * 
	 * @param minValue
	 *            The minimum value for the returned value
	 * @param maxValue
	 *            The maximum value for the returned value
	 * @return A double/Double value between min and max value (included)
	 */
	public static double getDoubleInRange(double minValue, double maxValue) {

		// This can happen. It's a way to specify a precise value
<span class="fc bfc" id="L276" title="All 2 branches covered.">		if (minValue == maxValue) {</span>
<span class="fc" id="L277">			return minValue;</span>
		}
		double retValue;
<span class="fc" id="L280">		double margin = (maxValue - minValue + 0.1);</span>
<span class="fc" id="L281">		Random random = ThreadLocalRandom.current();</span>
		do {
<span class="fc" id="L283">			retValue = minValue + random.nextDouble() * margin;</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">		} while (retValue &gt; maxValue);</span>
<span class="fc" id="L285">		return retValue;</span>
	}

	/**
	 * Finds boxed type for a primitive type
	 * 
	 * @param primitiveType
	 *            Primitive type to find boxed type for
	 * @return A boxed type or the same type, if original type was not primitive
	 */
	public static Class&lt;?&gt; primitiveToBoxedType(Class&lt;?&gt; primitiveType) {

<span class="fc bfc" id="L297" title="All 2 branches covered.">		if (int.class.equals(primitiveType)) {</span>
<span class="fc" id="L298">			return Integer.class;</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">		} else if (double.class.equals(primitiveType)) {</span>
<span class="fc" id="L300">			return Double.class;</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">		} else if (long.class.equals(primitiveType)) {</span>
<span class="fc" id="L302">			return Long.class;</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">		} else if (byte.class.equals(primitiveType)) {</span>
<span class="fc" id="L304">			return Byte.class;</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">		} else if (float.class.equals(primitiveType)) {</span>
<span class="fc" id="L306">			return Float.class;</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">		} else if (char.class.equals(primitiveType)) {</span>
<span class="nc" id="L308">			return Character.class;</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">		} else if (short.class.equals(primitiveType)) {</span>
<span class="fc" id="L310">			return Short.class;</span>
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">		} else if (boolean.class.equals(primitiveType)) {</span>
<span class="fc" id="L312">			return Boolean.class;</span>
		} else {
<span class="nc" id="L314">			return primitiveType;</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>